void voidHandler_() {}
void anyHandler_(var value) {}
void intHandler_(int value) {}
void floatHandler_(float value) {}
void boolHandler_(bool value) {}
void stringHandler_(String value) {}
var WIDTH = 1;
var HEIGHT = 2;
var OBLIQUE = 3;
int COLOR_RED = 0xFF0000;
int COLOR_GREEN = 0x00FF00;
int COLOR_YELLOW = 0xFFFF00;
int COLOR_BLUE = 0x0000FF;
int COLOR_BLACK = 0x000000;

void println(String str) {
/$console.log(str)$/
}
void post_(voidHandler_ handlerFn_) {
/$if (postHandler != null)
    console.log("postHandler not null");

  postHandler = handlerFn_$/
}
void executeEvents_() {
/$while (postHandler != null) {
    const fn = postHandler;
  
    postHandler = null;
    fn();
  }

//  this._refresh()$/
}
int max(int a, int b) {
/$return a > b ? a : b$/
}
float clock() {}
void saveContext() {
/$ctx.save()$/
}
void restoreContext() {
/$ctx.restore()$/
}
void oval(int pos, int size) {
/$ctx.fillStyle = toColor(getAttribute(10));
  ctx.globalAlpha = "" + getAttribute(11);
  ctx.beginPath();
  ctx.ellipse((pos >> 16) + (size >> 17), (pos & 65535) + ((size & 65535) >> 1), size >> 17, (size & 65535) >> 1, 0, 0, 2*Math.PI);
  ctx.fill();
  ctx.clip()$/
}
void rect(int pos, int size) {
/$ctx.fillStyle = toColor(getAttribute(10));
  ctx.globalAlpha = "" + getAttribute(11);
  ctx.beginPath();
  ctx.fillRect((pos >> 16), (pos & 65535), size >> 16, size & 65535)$/
}
void pushAttribute(int index, int value) {
/$if (attributeStacks[index] == undefined)
    attributeStacks[index] = [];

  attributeStacks[index].push(value)$/
}
void pushAttribute(int index, float value) {
/$pushAttribute(index, value)$/
}
void popAttribute(int index) {
/$attributeStacks[index].pop()$/
}
int getTextSize(String text) {
/$ctx.font = getAttribute(4) + "px Arial";

  const textSize = ctx.measureText(text);
  const height = textSize.fontBoundingBoxAscent + textSize.fontBoundingBoxDescent;
  return (textSize.width << 16) | height$/
}
void displayText(String text, int pos, int size) {
/$let pos1 = [(pos >> 16), (pos & 0xFFFF)];
  let size1 = [(size >> 16), (size & 0xFFFF)];
  ctx.font = getAttribute(4) + "px Arial";
  ctx.fillStyle = toColor(getAttribute(10));
  ctx.globalAlpha = getAttribute(11);
  ctx.textBaseline = "top";
  ctx.fillText(text, pos1[0], pos1[1])$/
}

bool Timer(int timeoutMillis) {
/$setTimeout(function() {
    handlerFn_(true);
    _refresh();
  }, timeoutMillis)$/

  void reset() {}
}
void Time(voidHandler_ Func) {
/$console.time("Time");
  new Func(() => {
    console.timeEnd("Time");
    handlerFn_();
  });$/
}
void time(voidHandler_ func) {
/$  console.time("time");
  func();
  console.timeEnd("time");$/
}
float Animation() {
/$requestAnimationFrame((millis) => {
  handlerFn_(millis);
  _refresh();
});$/
}
void InitFn(var array, int index, int[] pos) {}

void QEDArray(InitFn Init) {
  int size() {
    int s = 1

    for (int index = /$this.dims.size() - 1$/; index >= 0; index--)
      s *= /$this.dims[index]$/

    return s
  }

  void InitArray(int[] size) {
    /$QEDArray$this.dims = new Array(this.size$.length).fill(0)$/
    Insert(/$new Array(this.size$.length).fill(0)$/ as int[], size)
    return
  }

  void Insert(int[] pos, int[] size) {
    int[] newSize = /$[...this.size$]$/

    for (int index = /$QEDArray$this.dims.length - 1$/; index >= 0; index--)
      newSize[index] += /$QEDArray$this.dims[this.index]$/ as int;

    InsertLevel(/$QEDArray$this$/, /$QEDArray$this.dims$/, pos, size, newSize, /$new Array(this.size$.length).fill(0)$/, 0)
    /$QEDArray$this.dims$/ = newSize
    return
  }

  void InsertLevel(var array, var dims, int[] pos, int[] size, int[] newSize, var pp, int level) {
    if (level < /$QEDArray$this.dims.length - 1$/) {
      for (/$pp[level] = 0$/; /$pp[level] < pos[level]$/; /$pp[level]++$/)
        InsertLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)

      if (size[level] != 0)
        for (/$pp[level] = dims[level] - 1$/; /$pp[level] >= pos[level]$/; /$pp[level]--$/)
          /$array[pp[level] + InsertLevel$this.size$[level]] = array[pp[level]]$/

      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + InsertLevel$this.size$[level]$/; /$pp[level]++$/) {
        /$array[pp[level]] = []$/
        InsertLevel(/$array[pp[level]]$/, /$new Array(InsertLevel$this.size$.length).fill(0)$/, /$new Array(InsertLevel$this.size$.length).fill(0)$/ as int[], newSize, newSize, pp, level + 1)
      }

      for (/$pp[level] = pos[level] + InsertLevel$this.size$[level]$/; /$pp[level] < newSize[level]$/; /$pp[level]++$/)
        InsertLevel(/$array[pp[level]]$/, dims, pos, size, newSize, pp, level + 1)
    }
    else {
      if (size[level] != 0)
        for (/$pp[level] = dims[level] - 1$/; /$pp[level] >= pos[level]$/; /$pp[level]--$/)
          /$array[pp[level] + InsertLevel$this.size$[level]] = array[pp[level]]$/

      for (/$pp[level] = pos[level]$/; /$pp[level] < pos[level] + InsertLevel$this.size$[level]$/; /$pp[level]++$/)
        Init(array, /$pp[level]$/ as int, pp as int[])
    }
    return;
  }
/*
  void Push() {
    let pos = new Array(QEDArray$this.dims.length).fill(0);
    let size = new Array(QEDArray$this.dims.length).fill(0);

    pos[0] = QEDArray$this.dims[0];
    size[0] = 1;
    Insert(pos, size);
    return;
  }

  void pop() {
    let pos = new Array(QEDArray$this.dims.length).fill(0);
    let size = new Array(QEDArray$this.dims.length).fill(0);

    pos[0] = QEDArray$this.dims[0] - 1;
    size[0] = 1;
    remove(pos, size);
    return;
  }*/
}
/$Object.setPrototypeOf(QEDArray.prototype, Array.prototype)$/

